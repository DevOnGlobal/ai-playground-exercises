import { OutageIncident } from '../types/outage';import { FieldCrew, CrewAssignment, CrewSpecialization, CrewStatus } from '../types/crew';import { OutageDataLoader } from '../utils/dataLoader';export interface CrewRecommendation {  crewId: string;  matchScore: number;  estimatedResponseTime: number;  estimatedWorkDuration: number;  justification: string;}export class CrewDispatchService {  private availableCrews: FieldCrew[];  private activeAssignments: CrewAssignment[];  constructor() {    this.availableCrews = OutageDataLoader.loadCrewRoster();    this.activeAssignments = []; // This would typically be loaded from a persistent store  }  /**   * Finds the optimal crew for a given outage incident based on specialization, location, and workload.   * @param incident The outage incident to assign a crew to.   * @returns A CrewRecommendation object or null if no suitable crew is found.   */  findOptimalCrewForIncident(incident: OutageIncident): CrewRecommendation | null {    // TODO: Implement core dispatch methods.    // Scenario: Downtown transformer explosion requires substation tech with expert skill level    // Score crews based on specialization match (exact = 100%, related = 75%, other = 50%)    // Calculate travel time using calculateDistanceKm() and emergency vehicle speed (60 km/h)    // Consider crew workload (crews with existing assignments get lower scores)    // Apply incident priority multiplier to final scores    let bestRecommendation: CrewRecommendation | null = null;    let highestScore = -1;    for (const crew of this.availableCrews) {      if (crew.status !== CrewStatus.AVAILABLE) {        continue; // Only consider available crews      }      let matchScore = 0;      let justification = '';      // 1. Specialization Match      // This needs to be more dynamic based on incident's required specialization.      // For now, let's assume incident implies a need for LINE_WORKER or SUBSTATION_TECH      const requiredSpecialization = this.determineRequiredSpecialization(incident);      if (crew.specialization === requiredSpecialization) {        matchScore += 100;        justification += `Exact specialization match (${crew.specialization}). `;      } else if (this.isRelatedSpecialization(crew.specialization, requiredSpecialization)) {        matchScore += 75;        justification += `Related specialization match (${crew.specialization}). `;      } else {        matchScore += 50;        justification += `General specialization match (${crew.specialization}). `;      }      // Skill Level Bonus      if (crew.skillLevel === 'EXPERT') {        matchScore += 30;        justification += `Expert skill level. `;      } else if (crew.skillLevel === 'SENIOR') {        matchScore += 15;        justification += `Senior skill level. `;      }      // 2. Travel Time      const estimatedResponseTime = this.calculateResponseTime(crew, incident);      if (estimatedResponseTime === Infinity) continue; // Cannot reach incident      // Penalize for longer travel times (e.g., 1 point deduction per 5 minutes of travel)      matchScore -= Math.floor(estimatedResponseTime / 5);      justification += `Estimated response time: ${estimatedResponseTime} min. `;      // 3. Crew Workload (simplified: check if crew has current assignment)      if (crew.currentIncidentId) {        matchScore -= 50; // Significant penalty for already assigned crews        justification += `Crew is currently assigned to another incident. `;      }      // 4. Incident Priority Multiplier      // Assuming incident.priorityScore is already calculated and higher is better      matchScore *= (1 + (incident.priorityScore / 1000)); // Scale priority score to be a multiplier      // Estimated Work Duration (placeholder for now)      const estimatedWorkDuration = this.estimateWorkDuration(incident, crew);      justification += `Estimated work duration: ${estimatedWorkDuration} min.`;      if (matchScore > highestScore) {        highestScore = matchScore;        bestRecommendation = {          crewId: crew.id,          matchScore: matchScore,          estimatedResponseTime: estimatedResponseTime,          estimatedWorkDuration: estimatedWorkDuration,          justification: justification        };      }    }    return bestRecommendation;  }  /**   * Calculates the estimated response time for a crew to reach an incident.   * @param crew The field crew.   * @param incident The outage incident.   * @returns Estimated response time in minutes.   */  calculateResponseTime(crew: FieldCrew, incident: OutageIncident): number {    // TODO: Implement Haversine formula for distance calculation.    // Emergency vehicle average speed: 60 km/h in city, 80 km/h highway    // Add 15 minutes for crew preparation and equipment loading    // Return total estimated response time in minutes    const distanceKm = this.calculateDistanceKm(crew.currentLocation, incident.location);    // Assume city speed for simplicity, or add logic to determine environment    const speedKmH = 60; // km/h    const travelTimeHours = distanceKm / speedKmH;    const travelTimeMinutes = travelTimeHours * 60;    const preparationTimeMinutes = 15; // Fixed preparation time    return travelTimeMinutes + preparationTimeMinutes;  }  /**   * Balances workload across crews, reassigning incidents if a crew becomes overloaded.   * @param incidents A list of active outage incidents.   * @returns Recommendations for reassignments or a confirmation of balanced workload.   */  balanceWorkloadAcrossCrews(incidents: OutageIncident[]): string {    // TODO: Implement workload balancing.    // Business Rule: No crew should work more than 16 hours without 8-hour break    // Business Rule: Distribute workload to prevent single crew from handling all incidents    // Reassign incidents if crew becomes overloaded    // Return balanced assignment recommendations    // This is a complex optimization problem. For this exercise, we'll simplify.    // We'll just check for crews exceeding a hypothetical max work duration.    const crewWorkload: { [crewId: string]: number } = {}; // Stores total estimated work duration for each crew in minutes    // Initialize workload for all available crews    this.availableCrews.forEach(crew => {      crewWorkload[crew.id] = 0;    });    // Add current active assignments to workload    this.activeAssignments.forEach(assignment => {      if (crewWorkload[assignment.crewId] !== undefined) {        crewWorkload[assignment.crewId] += assignment.estimatedWorkDuration;      }    });    // Add estimated work for incidents that are not yet assigned but are active    incidents.forEach(incident => {      if (!incident.assignedCrewIds || incident.assignedCrewIds.length === 0) {        // This incident is unassigned, we need to consider it for balancing        // For simplicity, let's assume a default work duration for unassigned incidents        // A more robust solution would call estimateWorkDuration for each unassigned incident        const defaultWorkDuration = 120; // 2 hours        // We need to assign it to a crew to calculate its impact on workload.        // This function would typically be called *after* initial assignments.        // For balancing, we'd iterate through existing assignments and re-evaluate.      }    });    const maxWorkHours = 16; // Business rule: 16 hours    const maxWorkMinutes = maxWorkHours * 60;    let recommendations: string[] = [];    for (const crewId in crewWorkload) {      if (crewWorkload[crewId] > maxWorkMinutes) {        recommendations.push(`Crew ${crewId} is estimated to work ${crewWorkload[crewId] / 60} hours, exceeding the ${maxWorkHours}-hour limit. Consider reassigning some incidents.`);        // In a real system, you'd trigger a re-assignment process here.      }    }    if (recommendations.length === 0) {      return "Workload appears balanced across available crews within limits.";    } else {      return recommendations.join('\n');    }  }  // Helper for distance calculation (Haversine formula)  private calculateDistanceKm(point1: { latitude: number; longitude: number }, point2: { latitude: number; longitude: number }): number {    const R = 6371; // Radius of Earth in kilometers    const dLat = this.deg2rad(point2.latitude - point1.latitude);    const dLon = this.deg2rad(point2.longitude - point1.longitude);    const a =      Math.sin(dLat / 2) * Math.sin(dLat / 2) +      Math.cos(this.deg2rad(point1.latitude)) * Math.cos(this.deg2rad(point2.latitude)) *      Math.sin(dLon / 2) * Math.sin(dLon / 2);    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));    const d = R * c; // Distance in km    return d;  }  private deg2rad(deg: number): number {    return deg * (Math.PI / 180);  }  // Helper to determine required specialization based on incident cause/equipment  private determineRequiredSpecialization(incident: OutageIncident): CrewSpecialization {    // This is a simplified mapping. In a real system, this would be more sophisticated.    if (incident.cause === OutageCause.EQUIPMENT_FAILURE) {      // If it's a transformer or substation, likely SUBSTATION_TECH      if (incident.equipmentIds.some(id => id.startsWith('TRANS') || id.startsWith('SUB'))) {        return CrewSpecialization.SUBSTATION_TECH;      }      return CrewSpecialization.LINE_WORKER;    } else if (incident.cause === OutageCause.VEGETATION) {      return CrewSpecialization.TREE_REMOVAL;    } else if (incident.cause === OutageCause.VEHICLE_ACCIDENT) {      return CrewSpecialization.EMERGENCY_RESPONSE; // Or LINE_WORKER depending on damage    }    return CrewSpecialization.LINE_WORKER; // Default  }  // Helper to check for related specializations  private isRelatedSpecialization(crewSpec: CrewSpecialization, incidentSpec: CrewSpecialization): boolean {    // Define what constitutes "related" for your domain    if (crewSpec === CrewSpecialization.LINE_WORKER && incidentSpec === CrewSpecialization.SUBSTATION_TECH) return true;    if (crewSpec === CrewSpecialization.SUBSTATION_TECH && incidentSpec === CrewSpecialization.LINE_WORKER) return true;    // Add more rules as needed    return false;  }  // Helper to estimate work duration for an incident  private estimateWorkDuration(incident: OutageIncident, crew: FieldCrew): number {    // This is a placeholder. A real estimation would be complex.    // Factors: incident severity, cause, number of affected equipment, crew skill level.    let baseDurationMinutes = 60; // 1 hour default    switch (incident.severity) {      case OutageSeverity.MODERATE: baseDurationMinutes *= 1.5; break;      case OutageSeverity.MAJOR: baseDurationMinutes *= 2; break;      case OutageSeverity.CRITICAL: baseDurationMinutes *= 3; break;      case OutageSeverity.CATASTROPHIC: baseDurationMinutes *= 4; break;      default: break;    }    // Adjust based on crew skill (expert works faster)    if (crew.skillLevel === 'EXPERT') {      baseDurationMinutes *= 0.8;    } else if (crew.skillLevel === 'JUNIOR') {      baseDurationMinutes *= 1.2;    }    return baseDurationMinutes;  }}